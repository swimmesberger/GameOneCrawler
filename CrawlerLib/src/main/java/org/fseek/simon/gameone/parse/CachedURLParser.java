/*******************************************************************************
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *******************************************************************************/
package org.fseek.simon.gameone.parse;

import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Optional;

import org.fseek.simon.gameone.util.Check;
import org.fseek.simon.gameone.util.ErrorUtil;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.parser.Parser;

/**
 * Url parser which tries to read the data from the filesystem when a cache
 * directory was specified. When not cache file exists the cache will be
 * generated by writing the online resource to the specified cache directory.
 *
 * This prevents unnecessary roundtrips to the online resource when testing.
 */
public class CachedURLParser implements URLParser {
    private static final String CHARSET = "UTF-8";

    private final Optional<Path> cacheDir;
    private final URLParser delegate;

    public CachedURLParser(URLParser delegate) {
        this(delegate, null);
    }

    public CachedURLParser(URLParser delegate, Path cacheDir) {
        Check.requireNonNull(delegate);
        this.delegate = delegate;
        this.cacheDir = Optional.ofNullable(cacheDir);
    }

    @Override
    public Document parse(URL url, boolean xml) throws ParseException {
        String baseUri = url.toExternalForm();

        Optional<Path> cacheDirectory = getCacheDirectory();
        if (cacheDirectory.isPresent()) {
            Optional<Document> cache = readCacheFile(url, xml, baseUri, cacheDirectory.get());
            if (cache.isPresent()) {
                return cache.get();
            }
        }
        Optional<Document> online;
        ParseException error = null;
        try {
            online = Optional.of(parseDelegate(url, xml));
        } catch (MediaOfflineException ex) {
            online = Optional.empty();
            error = ex;
        }
        if (cacheDirectory.isPresent()) {
            writeCacheFile(url, online, cacheDirectory.get());
        }
        if (error != null) {
            throw error;
        }
        return online.get();
    }

    protected Document parseOffline(Path file, String baseUri, boolean xml) throws ParseException {
        try {
            if (xml) {
                try (InputStream in = Files.newInputStream(file)) {
                    return Jsoup.parse(in, null, baseUri, Parser.xmlParser());
                }
            } else {
                return Jsoup.parse(file.toFile(), null, baseUri);
            }
        } catch (IOException ex) {
            throw new ParseException(ex);
        }
    }

    protected Document parseDelegate(URL url, boolean xml) throws ParseException {
        return getDelegate().parse(url, xml);
    }

    public Optional<Path> getCacheDirectory() {
        return cacheDir;
    }

    protected Path getCacheFile(URL url, Path directory) throws UnsupportedEncodingException {
        String cacheFileName = URLEncoder.encode(url.getFile(), CHARSET);
        Path cacheFile = directory.resolve(cacheFileName);
        return cacheFile;
    }

    protected Path writeCacheFile(URL url, Optional<Document> doc, Path dir) throws ParseException {
        try {
            if (!Files.exists(dir)) {
                Files.createDirectories(dir);
            }
            Path cacheFile = getCacheFile(url, dir);
            byte[] bytes;
            if (doc.isPresent()) {
                bytes = doc.get().outerHtml().getBytes(CHARSET);
            } else {
                bytes = new byte[] {};
            }
            return Files.write(cacheFile, bytes, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.CREATE);
        } catch (IOException ex) {
            throw new ParseException(ex);
        }
    }

    protected Optional<Document> readCacheFile(URL url, boolean xml, String baseUri, Path dir) throws ParseException {
        try {
            Path cacheFile = getCacheFile(url, dir);
            if (Files.exists(cacheFile)) {
                Document parsedDoc = parseOffline(cacheFile, baseUri, xml);
                if (parsedDoc.childNodeSize() <= 0
                        || (parsedDoc.body() != null && parsedDoc.body().childNodeSize() <= 0)) {
                    throw ErrorUtil.offlineError("Media is offline!");
                }
                return Optional.of(parsedDoc);
            }
            return Optional.empty();
        } catch (IOException ex) {
            throw new ParseException(ex);
        }
    }

    public URLParser getDelegate() {
        return delegate;
    }
}
